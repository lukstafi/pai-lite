#!/usr/bin/env bash
set -euo pipefail

# Task aggregation for pai-lite

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$script_dir/common.sh"

pai_lite_projects_list() {
  local config
  config="$(pai_lite_config_path)"
  [[ -f "$config" ]] || pai_lite_die "config not found: $config"
  awk '
    function trim(s) {
      sub(/^[[:space:]]+/, "", s)
      sub(/[[:space:]]+$/, "", s)
      return s
    }
    /^[[:space:]]*projects:/ { in_projects=1; next }
    in_projects && $0 ~ /^[[:space:]]*$/ { next }
    in_projects && $0 !~ /^[[:space:]]/ { in_projects=0 }
    in_projects {
      if ($0 ~ /^[[:space:]]*-[[:space:]]*name:/) {
        if (name != "") {
          printf "%s|%s|%s|%s\n", name, repo, readme, issues
        }
        name=$0
        sub(/^[^:]+:[[:space:]]*/, "", name)
        name=trim(name)
        repo=""
        readme="false"
        issues="false"
      } else if ($0 ~ /^[[:space:]]*repo:/) {
        repo=$0
        sub(/^[^:]+:[[:space:]]*/, "", repo)
        repo=trim(repo)
      } else if ($0 ~ /^[[:space:]]*readme_todos:/) {
        readme=$0
        sub(/^[^:]+:[[:space:]]*/, "", readme)
        readme=trim(readme)
      } else if ($0 ~ /^[[:space:]]*issues:/) {
        issues=$0
        sub(/^[^:]+:[[:space:]]*/, "", issues)
        issues=trim(issues)
      }
    }
    END {
      if (name != "") {
        printf "%s|%s|%s|%s\n", name, repo, readme, issues
      }
    }
  ' "$config"
}

yaml_escape() {
  local value="$1"
  value=${value//\\/\\\\}
  value=${value//\"/\\\"}
  printf "%s" "$value"
}

tasks_file_path() {
  pai_lite_ensure_state_repo
  pai_lite_ensure_state_dir
  echo "$(pai_lite_state_harness_dir)/tasks.yaml"
}

tasks_sync() {
  local file tmp timestamp
  file="$(tasks_file_path)"
  tmp="${file}.tmp"
  timestamp="$(date -u +"%Y-%m-%dT%H:%MZ")"

  pai_lite_require_cmd gh

  {
    echo "# Generated by pai-lite"
    echo "generated_at: \"$timestamp\""
    echo "tasks:"

    while IFS='|' read -r name repo readme issues; do
      local repo_name
      repo_name="${repo##*/}"

      if [[ "$issues" == "true" ]]; then
        gh issue list -R "$repo" --state open --limit 200 \
          --json number,title,url,labels \
          --jq '.[] | [.number, .title, (.labels|map(.name)|join(",")), .url] | @tsv' \
          | while IFS=$'\t' read -r number title labels url; do
              local id escaped_title
              id="gh-${repo_name}-${number}"
              escaped_title="$(yaml_escape "$title")"
              echo "  - id: $id"
              echo "    title: \"$escaped_title\""
              echo "    source: github"
              echo "    repo: $repo"
              echo "    url: $url"
              echo "    state: open"
              if [[ -n "$labels" ]]; then
                echo "    labels: \"$(yaml_escape "$labels")\""
              else
                echo "    labels: \"\""
              fi
            done
      fi

      if [[ "$readme" == "true" ]]; then
        local repo_dir readme_file
        repo_dir="$HOME/$repo_name"
        if [[ ! -d "$repo_dir" && -d "$HOME/repos/$repo_name" ]]; then
          repo_dir="$HOME/repos/$repo_name"
        fi
        if [[ -d "$repo_dir" ]]; then
          readme_file=$(find "$repo_dir" -maxdepth 1 -iname "README*" | head -n 1)
          if [[ -n "$readme_file" ]]; then
            local line_no=0
            while IFS= read -r line || [[ -n "$line" ]]; do
              line_no=$((line_no + 1))
              if [[ "$line" =~ ^[[:space:]]*[-*][[:space:]]*\[[[:space:]]\][[:space:]]*(.+)$ ]]; then
                local task_text id escaped
                task_text="${BASH_REMATCH[1]:-}"
                id="readme-${repo_name}-${line_no}"
                escaped="$(yaml_escape "$task_text")"
                echo "  - id: $id"
                echo "    title: \"$escaped\""
                echo "    source: readme"
                echo "    repo: $repo"
                echo "    path: \"$(yaml_escape "$readme_file")\""
                echo "    line: $line_no"
              elif [[ "$line" =~ TODO[:[:space:]]*(.+)$ ]]; then
                local task_text id escaped
                task_text="${BASH_REMATCH[1]:-}"
                id="readme-${repo_name}-${line_no}"
                escaped="$(yaml_escape "$task_text")"
                echo "  - id: $id"
                echo "    title: \"$escaped\""
                echo "    source: readme"
                echo "    repo: $repo"
                echo "    path: \"$(yaml_escape "$readme_file")\""
                echo "    line: $line_no"
              fi
            done < "$readme_file"
          else
            pai_lite_warn "README not found for $repo"
          fi
        else
          pai_lite_warn "repo not found locally for README parsing: $repo_dir"
        fi
      fi
    done < <(pai_lite_projects_list)
  } > "$tmp"

  mv "$tmp" "$file"
  echo "Wrote tasks to $file"
}

tasks_list() {
  local file
  file="$(tasks_file_path)"
  [[ -f "$file" ]] || pai_lite_die "tasks file not found: $file (run: pai-lite tasks sync)"
  awk '
    /^[[:space:]]*-[[:space:]]*id:/ {
      id=$0
      sub(/.*id:[[:space:]]*/, "", id)
      gsub(/\"/, "", id)
      next
    }
    /^[[:space:]]*title:/ {
      if (id != "") {
        title=$0
        sub(/.*title:[[:space:]]*/, "", title)
        gsub(/^\"|\"$/, "", title)
        print id " - " title
        id=""
      }
    }
  ' "$file"
}

tasks_show() {
  local task_id="$1"
  local file
  file="$(tasks_file_path)"
  [[ -f "$file" ]] || pai_lite_die "tasks file not found: $file (run: pai-lite tasks sync)"
  awk -v target="$task_id" '
    /^[[:space:]]*-[[:space:]]*id:/ {
      current=$0
      sub(/.*id:[[:space:]]*/, "", current)
      gsub(/\"/, "", current)
      if (in_block && current != target) { exit }
      in_block=(current==target)
    }
    in_block { print }
  ' "$file"
}

#------------------------------------------------------------------------------
# Task file directory (individual task-*.md files for flow engine)
#------------------------------------------------------------------------------

tasks_dir_path() {
  pai_lite_ensure_state_repo
  pai_lite_ensure_state_dir
  echo "$(pai_lite_state_harness_dir)/tasks"
}

#------------------------------------------------------------------------------
# Convert tasks.yaml to individual task files
# Creates task-*.md files with YAML frontmatter for the flow engine
#------------------------------------------------------------------------------

tasks_convert() {
  local yaml_file tasks_dir
  yaml_file="$(tasks_file_path)"
  tasks_dir="$(tasks_dir_path)"

  [[ -f "$yaml_file" ]] || pai_lite_die "tasks.yaml not found (run: pai-lite tasks sync first)"

  mkdir -p "$tasks_dir"

  local today
  today=$(date +%Y-%m-%d)

  local count=0
  local current_id="" current_title="" current_source="" current_repo=""
  local current_url="" current_labels=""

  # Parse tasks.yaml and create individual files
  while IFS= read -r line; do
    # New task entry
    if [[ "$line" =~ ^[[:space:]]*-[[:space:]]*id:[[:space:]]*(.+)$ ]]; then
      # Capture new ID immediately (BASH_REMATCH is global and may be modified by tasks_write_file)
      local new_id="${BASH_REMATCH[1]:-}"
      # Write previous task if exists
      if [[ -n "$current_id" ]]; then
        tasks_write_file "$current_id" "$current_title" "$current_source" \
          "$current_repo" "$current_url" "$current_labels" "$today" "$tasks_dir"
        count=$((count + 1))
      fi
      current_id="$new_id"
      current_id="${current_id//\"/}"
      current_title=""
      current_source=""
      current_repo=""
      current_url=""
      current_labels=""
    elif [[ "$line" =~ ^[[:space:]]*title:[[:space:]]*\"?(.+)\"?$ ]]; then
      current_title="${BASH_REMATCH[1]:-}"
      current_title="${current_title%\"}"
    elif [[ "$line" =~ ^[[:space:]]*source:[[:space:]]*(.+)$ ]]; then
      current_source="${BASH_REMATCH[1]:-}"
    elif [[ "$line" =~ ^[[:space:]]*repo:[[:space:]]*(.+)$ ]]; then
      current_repo="${BASH_REMATCH[1]:-}"
    elif [[ "$line" =~ ^[[:space:]]*url:[[:space:]]*(.+)$ ]]; then
      current_url="${BASH_REMATCH[1]:-}"
    elif [[ "$line" =~ ^[[:space:]]*labels:[[:space:]]*\"?(.*)\"?$ ]]; then
      current_labels="${BASH_REMATCH[1]:-}"
      current_labels="${current_labels%\"}"
    fi
  done < "$yaml_file"

  # Write last task
  if [[ -n "$current_id" ]]; then
    tasks_write_file "$current_id" "$current_title" "$current_source" \
      "$current_repo" "$current_url" "$current_labels" "$today" "$tasks_dir"
    count=$((count + 1))
  fi

  echo "Created $count task files in $tasks_dir"
}

# Helper: Write individual task file
tasks_write_file() {
  local id="$1" title="$2" source="$3" repo="$4" url="$5" labels="$6" today="$7" dir="$8"

  # Skip if file already exists (don't overwrite user edits)
  local file="$dir/${id}.md"
  if [[ -f "$file" ]]; then
    pai_lite_info "skipping existing: $id"
    return
  fi

  # Infer priority from labels
  local priority="B"
  if [[ "$labels" =~ (urgent|critical|high|priority) ]]; then
    priority="A"
  elif [[ "$labels" =~ (low|minor|nice-to-have) ]]; then
    priority="C"
  fi

  # Infer project from repo
  local project=""
  if [[ -n "$repo" ]]; then
    project="${repo##*/}"
  fi

  # Write the task file
  cat > "$file" << EOF
---
id: $id
title: "$title"
project: $project
status: ready
priority: $priority
deadline: null
dependencies:
  blocks: []
  blocked_by: []
effort: medium
context: $project
slot: null
adapter: null
created: $today
started: null
completed: null
source: $source
EOF

  if [[ -n "$url" ]]; then
    echo "url: $url" >> "$file"
  fi
  if [[ "$source" == "github" && "$id" =~ gh-[^-]+-([0-9]+)$ ]]; then
    echo "github_issue: ${BASH_REMATCH[1]:-}" >> "$file"
  fi

  cat >> "$file" << EOF
---

# $title

## Context

$(if [[ -n "$url" ]]; then echo "Source: $url"; fi)
$(if [[ -n "$labels" ]]; then echo "Labels: $labels"; fi)

## Acceptance Criteria

- [ ] TBD

## Notes

EOF

  pai_lite_info "created: $id"
}

#------------------------------------------------------------------------------
# Create a new task manually
#------------------------------------------------------------------------------

tasks_create() {
  local title="$1"
  local project="${2:-personal}"
  local priority="${3:-B}"

  local tasks_dir
  tasks_dir="$(tasks_dir_path)"
  mkdir -p "$tasks_dir"

  # Generate task ID
  local count today id
  count=$(find "$tasks_dir" -name "task-*.md" 2>/dev/null | wc -l | tr -d ' ')
  count=$((count + 1))
  today=$(date +%Y-%m-%d)
  id="task-$(printf '%03d' "$count")"

  local file="$tasks_dir/${id}.md"

  cat > "$file" << EOF
---
id: $id
title: "$title"
project: $project
status: ready
priority: $priority
deadline: null
dependencies:
  blocks: []
  blocked_by: []
effort: medium
context: $project
slot: null
adapter: null
created: $today
started: null
completed: null
---

# $title

## Context

Created manually via pai-lite.

## Acceptance Criteria

- [ ] TBD

## Notes

EOF

  echo "Created task: $file"
  echo "ID: $id"
}

#------------------------------------------------------------------------------
# List task files (not tasks.yaml entries)
#------------------------------------------------------------------------------

tasks_files_list() {
  local tasks_dir
  tasks_dir="$(tasks_dir_path)"

  if [[ ! -d "$tasks_dir" ]]; then
    echo "No task files yet (run: pai-lite tasks convert)"
    return
  fi

  for file in "$tasks_dir"/*.md; do
    [[ -f "$file" ]] || continue
    # Extract id and title from frontmatter
    local id title status priority
    id=$(awk '/^id:/ { print $2; exit }' "$file")
    title=$(awk '/^title:/ { sub(/^title:[[:space:]]*"?/, ""); sub(/"?$/, ""); print; exit }' "$file")
    status=$(awk '/^status:/ { print $2; exit }' "$file")
    priority=$(awk '/^priority:/ { print $2; exit }' "$file")
    echo "$id ($priority) [$status] $title"
  done
}

#------------------------------------------------------------------------------
# Create sample task files for testing
#------------------------------------------------------------------------------

tasks_create_samples() {
  local tasks_dir
  tasks_dir="$(tasks_dir_path)"
  mkdir -p "$tasks_dir"

  local today
  today=$(date +%Y-%m-%d)

  # Sample 1: Ready high-priority task
  cat > "$tasks_dir/task-001.md" << EOF
---
id: task-001
title: "Implement user authentication"
project: sample-app
status: ready
priority: A
deadline: null
dependencies:
  blocks: [task-002, task-003]
  blocked_by: []
effort: large
context: auth
slot: null
adapter: null
created: $today
started: null
completed: null
---

# Implement user authentication

## Context

Sample task for testing pai-lite flow engine.

## Acceptance Criteria

- [ ] Login form works
- [ ] Session management implemented
- [ ] Logout functionality

## Notes

This is a sample task.
EOF

  # Sample 2: Blocked task
  cat > "$tasks_dir/task-002.md" << EOF
---
id: task-002
title: "Add password reset flow"
project: sample-app
status: ready
priority: B
deadline: null
dependencies:
  blocks: []
  blocked_by: [task-001]
effort: medium
context: auth
slot: null
adapter: null
created: $today
started: null
completed: null
---

# Add password reset flow

## Context

Depends on authentication being implemented first.

## Acceptance Criteria

- [ ] Reset email sent
- [ ] Token validation works
- [ ] Password update successful

## Notes

Blocked by task-001.
EOF

  # Sample 3: Task with deadline
  cat > "$tasks_dir/task-003.md" << EOF
---
id: task-003
title: "Write API documentation"
project: sample-app
status: ready
priority: B
deadline: $(date -v+14d +%Y-%m-%d 2>/dev/null || date -d "+14 days" +%Y-%m-%d 2>/dev/null || echo "2026-02-15")
dependencies:
  blocks: []
  blocked_by: [task-001]
effort: medium
context: docs
slot: null
adapter: null
created: $today
started: null
completed: null
---

# Write API documentation

## Context

Document the auth API endpoints.

## Acceptance Criteria

- [ ] All endpoints documented
- [ ] Examples provided
- [ ] Published to docs site

## Notes

Has a deadline for review.
EOF

  # Sample 4: In-progress stalled task
  local started_date
  started_date=$(date -v-10d +%Y-%m-%d 2>/dev/null || date -d "-10 days" +%Y-%m-%d 2>/dev/null || echo "2026-01-22")

  cat > "$tasks_dir/task-004.md" << EOF
---
id: task-004
title: "Refactor database layer"
project: sample-app
status: in-progress
priority: B
deadline: null
dependencies:
  blocks: []
  blocked_by: []
effort: large
context: backend
slot: null
adapter: null
created: $today
started: $started_date
completed: null
---

# Refactor database layer

## Context

Been working on this for a while...

## Acceptance Criteria

- [ ] New ORM integrated
- [ ] Migrations working
- [ ] Tests passing

## Notes

This task is intentionally stalled for testing critical view.
EOF

  # Sample 5: Low priority task
  cat > "$tasks_dir/task-005.md" << EOF
---
id: task-005
title: "Add dark mode support"
project: sample-app
status: ready
priority: C
deadline: null
dependencies:
  blocks: []
  blocked_by: []
effort: small
context: ui
slot: null
adapter: null
created: $today
started: null
completed: null
---

# Add dark mode support

## Context

Nice-to-have feature.

## Acceptance Criteria

- [ ] Theme toggle works
- [ ] Colors look good

## Notes

Low priority.
EOF

  echo "Created 5 sample task files in $tasks_dir"
  echo ""
  echo "Test with:"
  echo "  pai-lite flow ready      # Should show task-001, task-005"
  echo "  pai-lite flow blocked    # Should show task-002, task-003"
  echo "  pai-lite flow critical   # Should show deadline + stalled task"
  echo "  pai-lite flow impact task-001  # Should show task-002, task-003"
}

#------------------------------------------------------------------------------
# Detect tasks that need elaboration
# A task needs elaboration if:
#   - It has "- [ ] TBD" in Acceptance Criteria (template marker)
#   - OR it lacks an "elaborated:" field in frontmatter
# This has no false negatives on tasks created by tasks_convert() or tasks_create()
#------------------------------------------------------------------------------

tasks_needs_elaboration() {
  local tasks_dir
  tasks_dir="$(tasks_dir_path)"

  if [[ ! -d "$tasks_dir" ]]; then
    return
  fi

  for file in "$tasks_dir"/*.md; do
    [[ -f "$file" ]] || continue

    local id needs_elab=false

    # Extract task ID
    id=$(awk '/^id:/ { print $2; exit }' "$file")

    # Check 1: Has "elaborated:" in frontmatter?
    if ! grep -q '^elaborated:' "$file"; then
      needs_elab=true
    fi

    # Check 2: Has "- [ ] TBD" marker? (template placeholder)
    if grep -q '^\- \[ \] TBD$' "$file"; then
      needs_elab=true
    fi

    if [[ "$needs_elab" == "true" ]]; then
      echo "$id"
    fi
  done
}

# Check if a specific task needs elaboration
tasks_check_elaboration() {
  local task_id="$1"
  local tasks_dir file
  tasks_dir="$(tasks_dir_path)"
  file="$tasks_dir/${task_id}.md"

  if [[ ! -f "$file" ]]; then
    pai_lite_die "task file not found: $file"
  fi

  # Check for elaborated field
  if ! grep -q '^elaborated:' "$file"; then
    echo "needs-elaboration"
    return 0
  fi

  # Check for TBD marker
  if grep -q '^\- \[ \] TBD$' "$file"; then
    echo "needs-elaboration"
    return 0
  fi

  echo "elaborated"
  return 0
}
