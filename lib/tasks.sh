#!/usr/bin/env bash
set -euo pipefail

# Task aggregation for pai-lite

script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/common.sh
source "$script_dir/common.sh"

pai_lite_projects_list() {
  local config
  config="$(pai_lite_config_path)"
  [[ -f "$config" ]] || pai_lite_die "config not found: $config"
  awk '
    function trim(s) {
      sub(/^[[:space:]]+/, "", s)
      sub(/[[:space:]]+$/, "", s)
      return s
    }
    /^[[:space:]]*projects:/ { in_projects=1; next }
    in_projects && $0 !~ /^[[:space:]]/ { in_projects=0 }
    in_projects {
      if ($0 ~ /^[[:space:]]*-[[:space:]]*name:/) {
        if (name != "") {
          printf "%s|%s|%s|%s\n", name, repo, readme, issues
        }
        name=$0
        sub(/^[^:]+:[[:space:]]*/, "", name)
        name=trim(name)
        repo=""
        readme="false"
        issues="false"
      } else if ($0 ~ /^[[:space:]]*repo:/) {
        repo=$0
        sub(/^[^:]+:[[:space:]]*/, "", repo)
        repo=trim(repo)
      } else if ($0 ~ /^[[:space:]]*readme_todos:/) {
        readme=$0
        sub(/^[^:]+:[[:space:]]*/, "", readme)
        readme=trim(readme)
      } else if ($0 ~ /^[[:space:]]*issues:/) {
        issues=$0
        sub(/^[^:]+:[[:space:]]*/, "", issues)
        issues=trim(issues)
      }
    }
    END {
      if (name != "") {
        printf "%s|%s|%s|%s\n", name, repo, readme, issues
      }
    }
  ' "$config"
}

yaml_escape() {
  local value="$1"
  value=${value//\\/\\\\}
  value=${value//\"/\\\"}
  printf "%s" "$value"
}

tasks_file_path() {
  pai_lite_ensure_state_repo
  pai_lite_ensure_state_dir
  echo "$(pai_lite_state_harness_dir)/tasks.yaml"
}

tasks_sync() {
  local file tmp timestamp
  file="$(tasks_file_path)"
  tmp="${file}.tmp"
  timestamp="$(date -u +"%Y-%m-%dT%H:%MZ")"

  pai_lite_require_cmd gh

  {
    echo "# Generated by pai-lite"
    echo "generated_at: \"$timestamp\""
    echo "tasks:"

    while IFS='|' read -r name repo readme issues; do
      local repo_name
      repo_name="${repo##*/}"

      if [[ "$issues" == "true" ]]; then
        gh issue list -R "$repo" --state open --limit 200 \
          --json number,title,url,labels \
          --jq '.[] | [.number, .title, (.labels|map(.name)|join(",")), .url] | @tsv' \
          | while IFS=$'\t' read -r number title labels url; do
              local id escaped_title
              id="gh-${repo_name}-${number}"
              escaped_title="$(yaml_escape "$title")"
              echo "  - id: $id"
              echo "    title: \"$escaped_title\""
              echo "    source: github"
              echo "    repo: $repo"
              echo "    url: $url"
              echo "    state: open"
              if [[ -n "$labels" ]]; then
                echo "    labels: \"$(yaml_escape "$labels")\""
              else
                echo "    labels: \"\""
              fi
            done
      fi

      if [[ "$readme" == "true" ]]; then
        local repo_dir readme_file
        repo_dir="$HOME/$repo_name"
        if [[ ! -d "$repo_dir" && -d "$HOME/repos/$repo_name" ]]; then
          repo_dir="$HOME/repos/$repo_name"
        fi
        if [[ -d "$repo_dir" ]]; then
          readme_file=$(find "$repo_dir" -maxdepth 1 -iname "README*" | head -n 1)
          if [[ -n "$readme_file" ]]; then
            local line_no=0
            while IFS= read -r line || [[ -n "$line" ]]; do
              line_no=$((line_no + 1))
              if [[ "$line" =~ ^[[:space:]]*[-*][[:space:]]*\[[[:space:]]\][[:space:]]*(.+)$ ]]; then
                local task_text id escaped
                task_text="${BASH_REMATCH[1]}"
                id="readme-${repo_name}-${line_no}"
                escaped="$(yaml_escape "$task_text")"
                echo "  - id: $id"
                echo "    title: \"$escaped\""
                echo "    source: readme"
                echo "    repo: $repo"
                echo "    path: \"$(yaml_escape "$readme_file")\""
                echo "    line: $line_no"
              elif [[ "$line" =~ TODO[:[:space:]]*(.+)$ ]]; then
                local task_text id escaped
                task_text="${BASH_REMATCH[1]}"
                id="readme-${repo_name}-${line_no}"
                escaped="$(yaml_escape "$task_text")"
                echo "  - id: $id"
                echo "    title: \"$escaped\""
                echo "    source: readme"
                echo "    repo: $repo"
                echo "    path: \"$(yaml_escape "$readme_file")\""
                echo "    line: $line_no"
              fi
            done < "$readme_file"
          else
            pai_lite_warn "README not found for $repo"
          fi
        else
          pai_lite_warn "repo not found locally for README parsing: $repo_dir"
        fi
      fi
    done < <(pai_lite_projects_list)
  } > "$tmp"

  mv "$tmp" "$file"
  echo "Wrote tasks to $file"
}

tasks_list() {
  local file
  file="$(tasks_file_path)"
  [[ -f "$file" ]] || pai_lite_die "tasks file not found: $file (run: pai-lite tasks sync)"
  awk '
    /^[[:space:]]*-[[:space:]]*id:/ {
      id=$0
      sub(/.*id:[[:space:]]*/, "", id)
      gsub(/\"/, "", id)
      next
    }
    /^[[:space:]]*title:/ {
      if (id != "") {
        title=$0
        sub(/.*title:[[:space:]]*/, "", title)
        gsub(/^\"|\"$/, "", title)
        print id " - " title
        id=""
      }
    }
  ' "$file"
}

tasks_show() {
  local task_id="$1"
  local file
  file="$(tasks_file_path)"
  [[ -f "$file" ]] || pai_lite_die "tasks file not found: $file (run: pai-lite tasks sync)"
  awk -v target="$task_id" '
    /^[[:space:]]*-[[:space:]]*id:/ {
      current=$0
      sub(/.*id:[[:space:]]*/, "", current)
      gsub(/\"/, "", current)
      if (in_block && current != target) { exit }
      in_block=(current==target)
    }
    in_block { print }
  ' "$file"
}
