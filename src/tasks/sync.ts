// Task aggregation â€” sync from GitHub issues and watch paths

import { existsSync, readFileSync, writeFileSync, mkdirSync, readdirSync, appendFileSync } from "fs";
import { join, dirname } from "path";
import { loadConfigSync, harnessDir } from "../config.ts";
import { writeTaskFile } from "./markdown.ts";

function yamlEscape(value: string): string {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
}

function contentFingerprint(text: string): string {
  const normalized = text
    .toLowerCase()
    .replace(/[^a-z0-9 ]/g, "")
    .replace(/\s+/g, " ")
    .trim();

  // Use Bun's built-in hasher
  const hasher = new Bun.CryptoHasher("md5");
  hasher.update(normalized);
  return hasher.digest("hex").slice(0, 8);
}

function sanitizePathForId(path: string): string {
  const home = process.env.HOME ?? "";
  let p = path;
  if (p.startsWith(home + "/")) p = p.slice(home.length + 1);
  if (p.startsWith("~/")) p = p.slice(2);
  return p.replace(/[/. ]/g, "-").replace(/[^a-zA-Z0-9_-]/g, "");
}

interface GhIssue {
  number: number;
  title: string;
  url: string;
  labels: { name: string }[];
}

async function fetchGitHubIssues(repo: string): Promise<GhIssue[]> {
  const result = Bun.spawnSync(
    ["gh", "issue", "list", "-R", repo, "--state", "open", "--limit", "200", "--json", "number,title,url,labels"],
    { stdout: "pipe", stderr: "pipe" },
  );
  if (result.exitCode !== 0) {
    console.error(`pai-lite: failed to fetch issues from ${repo}: ${result.stderr.toString().trim()}`);
    return [];
  }
  try {
    return JSON.parse(result.stdout.toString()) as GhIssue[];
  } catch {
    return [];
  }
}

export async function tasksSync(): Promise<void> {
  const config = loadConfigSync();
  const harness = harnessDir();
  const yamlFile = join(harness, "tasks.yaml");
  const tasksDir = join(harness, "tasks");

  const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
  const lines: string[] = [
    "# Generated by pai-lite",
    `generated_at: "${timestamp}"`,
    "tasks:",
  ];

  // GitHub issues from projects config
  if (config.projects) {
    for (const project of config.projects) {
      if (!project.issues) continue;
      const issues = await fetchGitHubIssues(project.repo);
      const repoName = project.repo.split("/").pop()!;

      for (const issue of issues) {
        const id = `gh-${repoName}-${issue.number}`;
        const escapedTitle = yamlEscape(issue.title);
        const labelsStr = issue.labels.map((l) => l.name).join(",");
        lines.push(`  - id: ${id}`);
        lines.push(`    title: "${escapedTitle}"`);
        lines.push(`    source: github`);
        lines.push(`    repo: ${project.repo}`);
        lines.push(`    url: ${issue.url}`);
        lines.push(`    labels: "${yamlEscape(labelsStr)}"`);
      }
    }
  }

  // TODO: watch paths from triggers config (deferred to Phase 4 with triggers)

  writeFileSync(yamlFile, lines.join("\n") + "\n");
  console.log(`Wrote tasks to ${yamlFile}`);

  // Auto-convert to individual task files
  await tasksConvert();

  // Queue elaboration for new ready tasks
  tasksQueueElaborations();
}

export async function tasksConvert(): Promise<void> {
  const harness = harnessDir();
  const yamlFile = join(harness, "tasks.yaml");
  const tasksDir = join(harness, "tasks");

  if (!existsSync(yamlFile)) {
    throw new Error("tasks.yaml not found (run: pai-lite tasks sync first)");
  }

  mkdirSync(tasksDir, { recursive: true });
  const today = new Date().toISOString().slice(0, 10);

  const content = readFileSync(yamlFile, "utf-8");
  const lines = content.split("\n");

  let count = 0;
  let currentId = "";
  let currentTitle = "";
  let currentSource = "";
  let currentRepo = "";
  let currentUrl = "";
  let currentLabels = "";
  let currentPath = "";

  function flushCurrent(): void {
    if (!currentId) return;
    const created = writeTaskFile(
      tasksDir, currentId, currentTitle, currentSource,
      currentRepo, currentUrl, currentLabels, today, currentPath || undefined,
    );
    if (created) count++;
  }

  for (const line of lines) {
    let m: RegExpMatchArray | null;

    m = line.match(/^\s*-\s*id:\s*(.+)$/);
    if (m) {
      flushCurrent();
      currentId = m[1]!.replace(/"/g, "");
      currentTitle = "";
      currentSource = "";
      currentRepo = "";
      currentUrl = "";
      currentLabels = "";
      currentPath = "";
      continue;
    }

    m = line.match(/^\s*title:\s*"?(.+?)"?\s*$/);
    if (m) { currentTitle = m[1]!.replace(/"$/, ""); continue; }

    m = line.match(/^\s*source:\s*(.+)$/);
    if (m) { currentSource = m[1]!; continue; }

    m = line.match(/^\s*repo:\s*(.+)$/);
    if (m) { currentRepo = m[1]!; continue; }

    m = line.match(/^\s*url:\s*(.+)$/);
    if (m) { currentUrl = m[1]!; continue; }

    m = line.match(/^\s*labels:\s*"?(.*?)"?\s*$/);
    if (m) { currentLabels = m[1]!.replace(/"$/, ""); continue; }

    m = line.match(/^\s*path:\s*"?(.+?)"?\s*$/);
    if (m) { currentPath = m[1]!.replace(/"$/, ""); continue; }
  }

  flushCurrent();
  console.log(`Created ${count} task files in ${tasksDir}`);
}

function tasksQueueElaborations(): void {
  const harness = harnessDir();
  const tasksDir = join(harness, "tasks");
  if (!existsSync(tasksDir)) return;

  const queueFile = join(harness, "mayor", "queue.jsonl");
  let alreadyQueued = "";
  if (existsSync(queueFile)) {
    const content = readFileSync(queueFile, "utf-8");
    alreadyQueued = content.split("\n").filter((l) => l.includes('"action":"elaborate"')).join("\n");
  }

  const needsElab = tasksNeedsElaborationList(tasksDir);
  let count = 0;

  for (const taskId of needsElab) {
    const file = join(tasksDir, `${taskId}.md`);
    if (!existsSync(file)) continue;

    const content = readFileSync(file, "utf-8");
    const statusMatch = content.match(/^status:\s*(.+)$/m);
    if (statusMatch && statusMatch[1]!.trim() !== "ready") continue;

    if (alreadyQueued.includes(`"task":"${taskId}"`)) continue;

    mkdirSync(dirname(queueFile), { recursive: true });
    const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, "Z");
    const requestId = `req-${Math.floor(Date.now() / 1000)}-${process.pid}`;
    const request = `{"id":"${requestId}","action":"elaborate","timestamp":"${timestamp}","task":"${taskId}"}`;
    appendFileSync(queueFile, request + "\n");
    count++;
  }

  if (count > 0) {
    console.error(`pai-lite: Queued ${count} task(s) for elaboration`);
  }
}

function tasksNeedsElaborationList(tasksDir: string): string[] {
  const files = readdirSync(tasksDir).filter((f: string) => f.endsWith(".md"));
  const result: string[] = [];

  for (const f of files) {
    const content = readFileSync(join(tasksDir, f), "utf-8");
    const idMatch = content.match(/^id:\s*(.+)$/m);
    if (!idMatch) continue;
    const id = idMatch[1]!.trim();

    const statusMatch = content.match(/^status:\s*(.+)$/m);
    const status = statusMatch ? statusMatch[1]!.trim() : "";
    if (["merged", "done", "abandoned"].includes(status)) continue;

    let needsElab = false;
    if (!content.includes("\nelaborated:")) needsElab = true;
    if (content.includes("- [ ] TBD\n")) needsElab = true;

    if (needsElab) result.push(id);
  }

  return result;
}

export { tasksNeedsElaborationList, tasksQueueElaborations, contentFingerprint };
