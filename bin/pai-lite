#!/usr/bin/env bash
set -euo pipefail

# Resolve symlinks to find real script location
script_path="${BASH_SOURCE[0]}"
while [[ -L "$script_path" ]]; do
  script_dir="$(cd "$(dirname "$script_path")" && pwd)"
  script_path="$(readlink "$script_path")"
  # Handle relative symlinks
  [[ "$script_path" != /* ]] && script_path="$script_dir/$script_path"
done
root_dir="$(cd "$(dirname "$script_path")/.." && pwd)"

# shellcheck source=lib/common.sh
source "$root_dir/lib/common.sh"
# shellcheck source=lib/slots.sh
source "$root_dir/lib/slots.sh"
# shellcheck source=lib/tasks.sh
source "$root_dir/lib/tasks.sh"
# shellcheck source=lib/sessions.sh
source "$root_dir/lib/sessions.sh"
# shellcheck source=lib/triggers.sh
source "$root_dir/lib/triggers.sh"
# shellcheck source=lib/flow.sh
source "$root_dir/lib/flow.sh"
# shellcheck source=lib/notify.sh
source "$root_dir/lib/notify.sh"
# shellcheck source=lib/dashboard.sh
source "$root_dir/lib/dashboard.sh"
# shellcheck source=lib/mayor.sh
source "$root_dir/lib/mayor.sh"

usage() {
  cat <<'USAGE'
Usage: pai-lite <command>

Commands:
  slots                        Show all slots
  slots refresh                Refresh slot state from adapters
  sessions                     List discovered sessions
  sessions refresh             Refresh sessions discovery
  sessions show                Show raw sessions JSON
  slot <n>                     Show slot n
  slot <n> assign <task|desc> [-a adapter] [-s session] [-p path]
                               Assign a task to slot n
  slot <n> clear [done|abandoned]
                               Clear slot n (optionally mark task done/abandoned)
  slot <n> start               Start agent session (adapter)
  slot <n> stop                Stop agent session (adapter)
  slot <n> note "text"         Add runtime note to slot n

  tasks sync                   Aggregate tasks and convert to task files
  tasks list                   Show unified task list
  tasks show <id>              Show task details
  tasks convert                Convert tasks.yaml to individual task files (also run by sync)
  tasks create <title>         Create a new task manually
  tasks files                  List individual task files
  tasks samples                Create sample tasks for testing
  tasks needs-elaboration      List tasks needing elaboration
  tasks queue-elaborations     Queue elaboration for unprocessed ready tasks
  tasks check <id>             Check if task needs elaboration

  flow ready                   Priority-sorted ready tasks
  flow blocked                 What's blocked and why
  flow critical                Deadlines + stalled + high-priority
  flow impact <id>             What this task unblocks
  flow context                 Context distribution across slots
  flow check-cycle             Check for dependency cycles

  mayor start [--no-ttyd]      Start Mayor tmux session (with ttyd by default)
  mayor stop                   Stop Mayor tmux session
  mayor status                 Show Mayor status
  mayor attach                 Attach to Mayor tmux session
  mayor logs [n]               Show recent Mayor activity
  mayor doctor                 Health check for Mayor setup
  mayor briefing               Request morning briefing
  mayor suggest                Get task suggestions
  mayor analyze <issue>        Analyze GitHub issue
  mayor elaborate <id>         Elaborate task into detailed spec
  mayor health-check           Check for stalled work, deadlines
  mayor message "text"          Send async message to Mayor
  mayor inbox                  Show and consume pending messages
  mayor queue                  Show pending queue requests

  notify pai <msg>             Send strategic notification
  notify agents <msg>          Send operational notification
  notify public <msg>          Send public broadcast
  notify recent [n]            Show recent notifications

  dashboard generate           Generate JSON data for dashboard
  dashboard serve [port]       Serve dashboard (default: 7678)
  dashboard install            Install dashboard to state repo

  sync                         Pull + push state repo (full sync)
  state pull                   Pull latest from state repo
  state push                   Push local changes to state repo

  journal                      Show today's journal entries
  journal recent [n]           Show last n journal entries
  journal list [days]          List journal files from last n days

  network status               Show network configuration
  federation status            Show federation status (multi-machine Mayor)
  federation tick              Publish heartbeat and run leader election
  federation elect             Run leader election only
  federation heartbeat         Publish heartbeat only

  status                       Overview of slots + tasks
  briefing                     Morning briefing
  init [--no-hooks] [--no-dashboard] [--no-triggers]
                               Initialize config, harness, hooks, dashboard, and triggers
  triggers install             Install launchd/systemd triggers
  triggers status              Show trigger status
  triggers uninstall           Remove all triggers
  doctor                       Check system health and dependencies

  help                         Show this message
USAGE
}

require_config() {
  local config
  config="$(pai_lite_config_path)"
  [[ -f "$config" ]] || pai_lite_die "config not found: $config (run: pai-lite init)"
}

cmd="${1:-}"
case "$cmd" in
  help|-h|--help|"")
    usage
    exit 0
    ;;
  init)
    # Install to ~/.local/pai-lite with symlink in ~/.local/bin
    local_install="$HOME/.local/pai-lite"
    local_bin="$HOME/.local/bin"

    # Copy entire directory structure (including skills for Mayor)
    mkdir -p "$local_install"
    cp -r "$root_dir"/{bin,lib,adapters,templates,skills} "$local_install/"

    # Create symlink in ~/.local/bin
    mkdir -p "$local_bin"
    ln -sf "$local_install/bin/pai-lite" "$local_bin/pai-lite"

    echo "Installed pai-lite to $local_install"
    echo "Symlinked $local_bin/pai-lite -> $local_install/bin/pai-lite"

    # Check if ~/.local/bin is in PATH
    if [[ ":$PATH:" != *":$local_bin:"* ]]; then
      pai_lite_warn "$local_bin is not in PATH; add it to your shell profile:"
      echo "  export PATH=\"\$PATH:$local_bin\""
    fi

    config_path="$(pai_lite_config_path)"
    config_dir="$(dirname "$config_path")"
    mkdir -p "$config_dir"

    if [[ -f "$config_path" ]]; then
      pai_lite_warn "config already exists: $config_path"
    else
      cp "$root_dir/templates/config.example.yaml" "$config_path"
      echo "Created config: $config_path"
    fi

    if [[ -f "$config_path" ]]; then
      state_repo="$(pai_lite_state_repo_slug)"
      if [[ "$state_repo" == *"your-username"* ]]; then
        pai_lite_warn "config still uses placeholder state_repo; update it before cloning"
      else
        pai_lite_ensure_state_repo
        pai_lite_ensure_state_dir
        harness_dir="$(pai_lite_state_harness_dir)"
        if [[ ! -f "$harness_dir/config.yaml" ]]; then
          cp "$root_dir/templates/harness/config.yaml" "$harness_dir/config.yaml"
        fi
        if [[ ! -f "$harness_dir/slots.md" ]]; then
          cp "$root_dir/templates/harness/slots.md" "$harness_dir/slots.md"
        fi

        # Create Mayor directory structure
        mayor_dir="$harness_dir/mayor"
        mkdir -p "$mayor_dir/memory/projects"
        if [[ ! -f "$mayor_dir/context.md" ]]; then
          cp "$root_dir/templates/mayor/context.md" "$mayor_dir/context.md" 2>/dev/null || \
            echo "# Mayor Context" > "$mayor_dir/context.md"
        fi
        if [[ ! -f "$mayor_dir/memory/corrections.md" ]]; then
          cp "$root_dir/templates/mayor/memory/corrections.md" "$mayor_dir/memory/corrections.md" 2>/dev/null || \
            echo "# Corrections" > "$mayor_dir/memory/corrections.md"
        fi
        if [[ ! -f "$mayor_dir/memory/tools.md" ]]; then
          cp "$root_dir/templates/mayor/memory/tools.md" "$mayor_dir/memory/tools.md" 2>/dev/null || \
            echo "# Tools Knowledge" > "$mayor_dir/memory/tools.md"
        fi
        if [[ ! -f "$mayor_dir/memory/workflows.md" ]]; then
          cp "$root_dir/templates/mayor/memory/workflows.md" "$mayor_dir/memory/workflows.md" 2>/dev/null || \
            echo "# Workflows" > "$mayor_dir/memory/workflows.md"
        fi
        echo "Initialized Mayor memory in: $mayor_dir"

        echo "Initialized harness in: $harness_dir"
      fi
    fi

    # Parse init flags (hooks, dashboard, triggers installed by default)
    install_hooks=true install_dashboard=true install_triggers=true
    shift  # consume 'init'
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --no-hooks)      install_hooks=false ;;
        --no-dashboard)  install_dashboard=false ;;
        --no-triggers)   install_triggers=false ;;
        --hooks)         install_hooks=true ;;    # legacy flag, now default
        *) ;;
      esac
      shift
    done

    # Install skills and hooks (default: yes, skip with --no-hooks)
    if [[ "$install_hooks" == "true" ]]; then
      echo ""
      echo "=== Installing Skills and Hooks ==="

      # Install skills to state harness directory (project-scoped for Mayor)
      claude_skills="$harness_dir/.claude/commands"
      mkdir -p "$claude_skills"

      skill_count=0
      for skill_file in "$local_install/skills"/*.md; do
        [[ -f "$skill_file" ]] || continue
        skill_name="$(basename "$skill_file")"
        cp "$skill_file" "$claude_skills/$skill_name"
        skill_count=$((skill_count + 1))
      done
      echo "Installed $skill_count skills to $claude_skills"

      # Install stop hook script
      hook_script="$local_bin/pai-lite-on-stop"
      if [[ -f "$root_dir/templates/hooks/pai-lite-on-stop.sh" ]]; then
        cp "$root_dir/templates/hooks/pai-lite-on-stop.sh" "$hook_script"
        chmod +x "$hook_script"
        echo "Installed stop hook script: $hook_script"
      fi

      # Configure Claude settings.json to use the stop hook
      claude_settings="$HOME/.claude/settings.json"
      if [[ -f "$claude_settings" ]]; then
        # Check if hooks already configured
        if grep -q '"hooks"' "$claude_settings" 2>/dev/null; then
          pai_lite_warn "Claude settings already has 'hooks' - not overwriting"
          echo "To enable pai-lite hook, manually add to $claude_settings:"
          echo "  \"hooks\": {\"Stop\": [{\"matcher\": \"\", \"hooks\": [{\"type\": \"command\", \"command\": \"$hook_script\"}]}]}"
        else
          # Add hooks to existing settings using jq
          if command -v jq >/dev/null 2>&1; then
            tmp_settings="$(mktemp)"
            jq --arg cmd "$hook_script" \
              '.hooks = {"Stop": [{"matcher": "", "hooks": [{"type": "command", "command": $cmd}]}]}' \
              "$claude_settings" > "$tmp_settings"
            mv "$tmp_settings" "$claude_settings"
            echo "Configured Stop hook in $claude_settings"
          else
            pai_lite_warn "jq not found - please manually add hooks to $claude_settings"
          fi
        fi
      else
        # Create new settings file with hooks
        mkdir -p "$(dirname "$claude_settings")"
        if command -v jq >/dev/null 2>&1; then
          jq -n --arg cmd "$hook_script" \
            '{hooks: {"Stop": [{"matcher": "", "hooks": [{"type": "command", "command": $cmd}]}]}}' \
            > "$claude_settings"
          echo "Created $claude_settings with Stop hook"
        else
          pai_lite_warn "jq not found - please create $claude_settings manually"
        fi
      fi

      echo ""
      echo "Skills installed (in state harness for Mayor):"
      for skill_file in "$claude_skills"/*.md; do
        [[ -f "$skill_file" ]] || continue
        skill_name="$(basename "$skill_file" .md)"
        echo "  /$skill_name"
      done
    else
      echo ""
      echo "Skipped hooks installation (use init without --no-hooks to install)"
    fi

    # Install dashboard (default: yes, skip with --no-dashboard)
    if [[ "$install_dashboard" == "true" ]]; then
      echo ""
      echo "=== Installing Dashboard ==="
      dashboard_install
    else
      echo ""
      echo "Skipped dashboard installation (use init without --no-dashboard to install)"
    fi

    # Install triggers (default: yes, skip with --no-triggers)
    if [[ "$install_triggers" == "true" ]]; then
      echo ""
      echo "=== Installing Triggers ==="
      triggers_install
    else
      echo ""
      echo "Skipped triggers installation (use init without --no-triggers to install)"
    fi
    ;;
  slots)
    require_config
    sub="${2:-}"
    case "$sub" in
      refresh)
        slots_refresh
        ;;
      "")
        slots_list
        ;;
      *)
        pai_lite_die "unknown slots subcommand: $sub (use: refresh, or omit for list)"
        ;;
    esac
    ;;
  sessions)
    require_config
    sub="${2:-}"
    case "$sub" in
      refresh)
        sessions_refresh
        ;;
      show)
        sessions_show
        ;;
      "")
        sessions_list
        ;;
      *)
        pai_lite_die "unknown sessions subcommand: $sub (use: refresh, show, or omit for list)"
        ;;
    esac
    ;;
  slot)
    require_config
    slot_num="${2:-}"
    [[ -n "$slot_num" ]] || pai_lite_die "slot number required"
    action="${3:-}"
    case "$action" in
      "")
        slot_show "$slot_num"
        ;;
      assign)
        shift 3  # Remove "pai-lite slot <n> assign"
        # Parse flags and task description
        adapter="manual"
        session=""
        slot_path=""
        task_or_desc=""
        while [[ $# -gt 0 ]]; do
          case "$1" in
            --adapter|-a)
              adapter="${2:-manual}"
              shift 2
              ;;
            --session|-s)
              session="${2:-}"
              shift 2
              ;;
            --path|-p)
              slot_path="${2:-}"
              shift 2
              ;;
            *)
              # Accumulate remaining args as task description
              if [[ -n "$task_or_desc" ]]; then
                task_or_desc="$task_or_desc $1"
              else
                task_or_desc="$1"
              fi
              shift
              ;;
          esac
        done
        [[ -n "$task_or_desc" ]] || pai_lite_die "task or description required"
        slot_assign "$slot_num" "$task_or_desc" "$adapter" "$session" "$slot_path"
        ;;
      clear)
        final_status="${4:-ready}"
        # Validate final_status
        case "$final_status" in
          ready|done|abandoned)
            slot_clear "$slot_num" "$final_status"
            ;;
          *)
            pai_lite_die "invalid status: $final_status (use: ready, done, abandoned)"
            ;;
        esac
        ;;
      start)
        slot_start "$slot_num"
        ;;
      stop)
        slot_stop "$slot_num"
        ;;
      note)
        shift 3
        [[ -n "${*:-}" ]] || pai_lite_die "note text required"
        slot_note "$slot_num" "$*"
        ;;
      *)
        pai_lite_die "unknown slot action: $action"
        ;;
    esac
    ;;
  tasks)
    require_config
    sub="${2:-}"
    case "$sub" in
      sync)
        tasks_sync
        ;;
      list)
        tasks_list
        ;;
      show)
        task_id="${3:-}"
        [[ -n "$task_id" ]] || pai_lite_die "task id required"
        tasks_show "$task_id"
        ;;
      convert)
        tasks_convert
        ;;
      create)
        shift 2
        [[ -n "${1:-}" ]] || pai_lite_die "task title required"
        title="$1"
        project="${2:-personal}"
        priority="${3:-B}"
        tasks_create "$title" "$project" "$priority"
        ;;
      files)
        tasks_files_list
        ;;
      samples)
        tasks_create_samples
        ;;
      needs-elaboration)
        tasks_needs_elaboration
        ;;
      queue-elaborations)
        tasks_queue_elaborations
        ;;
      check)
        task_id="${3:-}"
        [[ -n "$task_id" ]] || pai_lite_die "task id required"
        tasks_check_elaboration "$task_id"
        ;;
      *)
        pai_lite_die "unknown tasks subcommand: $sub (use: sync, list, show, convert, create, files, samples, needs-elaboration, queue-elaborations, check)"
        ;;
    esac
    ;;
  status)
    require_config
    echo "=== pai-lite status - $(date) ==="
    echo ""

    # Mayor status (brief)
    echo "Mayor:"
    if mayor_is_running; then
      echo "  Session: $MAYOR_SESSION_NAME (running)"
      _queue_file="$(pai_lite_queue_file)"
      if [[ -f "$_queue_file" ]] && [[ -s "$_queue_file" ]]; then
        _pending_count=$(wc -l < "$_queue_file" | tr -d ' ')
        echo "  Pending requests: $_pending_count"
      else
        echo "  Pending requests: 0"
      fi
    else
      echo "  Session: not running"
    fi
    echo ""

    echo "Slots:"
    slots_list || true
    echo ""
    if [[ -f "$(tasks_file_path)" ]]; then
      echo "Tasks:"
      tasks_list | head -n 10
    else
      echo "Tasks: (run 'pai-lite tasks sync')"
    fi
    ;;
  briefing)
    require_config
    echo "=== pai-lite briefing - $(date) ==="
    echo ""

    # Quick status first
    echo "Slots:"
    slots_list || true
    echo ""

    # Check if Mayor is running and queue a briefing
    if mayor_is_running; then
      echo "Requesting strategic briefing from Mayor..."
      echo ""
      mayor_briefing true 300
    else
      # Fallback to basic briefing without Mayor
      echo "Mayor not running - showing basic briefing"
      echo "(Start Mayor with: pai-lite mayor start)"
      echo ""

      if [[ -f "$(tasks_file_path)" ]]; then
        echo "Tasks:"
        tasks_list
      else
        echo "Tasks: (run 'pai-lite tasks sync')"
      fi

      # Show flow critical if available
      echo ""
      echo "Critical items:"
      flow_main critical 2>/dev/null || echo "  (flow engine not initialized)"
    fi
    ;;
  triggers)
    require_config
    sub="${2:-}"
    case "$sub" in
      install)
        triggers_install
        ;;
      status)
        triggers_status
        ;;
      uninstall)
        triggers_uninstall
        ;;
      *)
        pai_lite_die "unknown triggers subcommand: $sub (use: install, status, uninstall)"
        ;;
    esac
    ;;
  flow)
    require_config
    shift
    flow_main "$@"
    ;;
  mayor)
    require_config
    sub="${2:-}"
    case "$sub" in
      start)
        shift 2  # Remove 'mayor start'
        mayor_start "$@"
        ;;
      stop)
        mayor_stop
        ;;
      status)
        mayor_status
        ;;
      attach)
        mayor_attach
        ;;
      logs)
        lines="${3:-100}"
        mayor_logs "$lines"
        ;;
      doctor)
        mayor_doctor
        ;;
      briefing)
        # Queue and optionally wait for briefing
        wait_flag="${3:-}"
        if [[ "$wait_flag" == "--no-wait" ]]; then
          request_id=$(pai_lite_queue_request "briefing")
          echo "Queued briefing request: $request_id"
          echo "Mayor will process when ready"
        else
          mayor_briefing true
        fi
        ;;
      suggest)
        request_id=$(pai_lite_queue_request "suggest")
        echo "Queued suggestion request: $request_id"
        ;;
      analyze)
        issue="${3:-}"
        [[ -n "$issue" ]] || pai_lite_die "issue number or URL required"
        request_id=$(pai_lite_queue_request "analyze-issue" "\"issue\":\"$issue\"")
        echo "Queued issue analysis: $request_id"
        ;;
      elaborate)
        task_id="${3:-}"
        [[ -n "$task_id" ]] || pai_lite_die "task id required"
        request_id=$(pai_lite_queue_request "elaborate" "\"task\":\"$task_id\"")
        echo "Queued task elaboration: $request_id"
        ;;
      health-check)
        request_id=$(pai_lite_queue_request "health-check")
        echo "Queued health check: $request_id"
        ;;
      learn)
        request_id=$(pai_lite_queue_request "learn")
        echo "Queued learn request: $request_id"
        ;;
      sync-learnings)
        request_id=$(pai_lite_queue_request "sync-learnings")
        echo "Queued sync-learnings request: $request_id"
        ;;
      techdebt)
        request_id=$(pai_lite_queue_request "techdebt")
        echo "Queued techdebt review: $request_id"
        ;;
      context-sync)
        request_id=$(pai_lite_queue_request "context-sync")
        echo "Queued context-sync: $request_id"
        ;;
      message)
        shift 2  # Remove 'mayor message'
        [[ -n "${*:-}" ]] || pai_lite_die "message text required"
        pai_lite_inbox_append "$*"
        echo "Message added to Mayor inbox"
        # Commit and push so messages sent from any machine reach Mayor
        pai_lite_state_sync "inbox: new message"
        # Queue a message action if queue is empty (so stop hook triggers processing)
        if ! pai_lite_queue_pending; then
          request_id=$(pai_lite_queue_request "message")
          echo "Queued message processing: $request_id"
        else
          echo "Queue already has pending requests; Mayor will read inbox when processing"
        fi
        ;;
      inbox)
        pai_lite_inbox_consume
        ;;
      queue)
        # Show pending queue
        queue_file="$(pai_lite_queue_file)"
        if [[ -f "$queue_file" ]] && [[ -s "$queue_file" ]]; then
          echo "Pending requests:"
          cat "$queue_file"
        else
          echo "No pending requests in queue"
        fi
        ;;
      queue-pop)
        # Pop next request and output Stop hook JSON (used by stop hook)
        # Optional arg: cwd of the calling session (to verify it's the Mayor)
        mayor_queue_pop "${3:-}"
        ;;
      "")
        # No subcommand - show status
        mayor_status
        ;;
      *)
        pai_lite_die "unknown mayor subcommand: $sub (use: start, stop, status, attach, logs, doctor, briefing, suggest, analyze, elaborate, health-check, learn, sync-learnings, techdebt, context-sync, message, inbox, queue)"
        ;;
    esac
    ;;
  notify)
    require_config
    sub="${2:-}"
    case "$sub" in
      pai)
        shift 2
        [[ -n "${*:-}" ]] || pai_lite_die "message required"
        notify_pai "$*"
        echo "Notification sent to pai topic"
        ;;
      agents)
        shift 2
        [[ -n "${*:-}" ]] || pai_lite_die "message required"
        notify_agents "$*"
        echo "Notification sent to agents topic"
        ;;
      public)
        shift 2
        [[ -n "${*:-}" ]] || pai_lite_die "message required"
        notify_public "$*"
        echo "Notification sent to public topic"
        ;;
      recent)
        count="${3:-10}"
        notify_recent "$count"
        ;;
      *)
        pai_lite_die "unknown notify subcommand: $sub (use: pai, agents, public, recent)"
        ;;
    esac
    ;;
  dashboard)
    require_config
    shift
    dashboard_main "$@"
    ;;
  sync)
    require_config
    pai_lite_state_full_sync
    echo "State sync complete"
    ;;
  state)
    require_config
    sub="${2:-}"
    case "$sub" in
      pull)
        pai_lite_state_pull
        ;;
      push)
        pai_lite_state_push
        ;;
      sync)
        pai_lite_state_full_sync
        ;;
      *)
        pai_lite_die "unknown state subcommand: $sub (use: pull, push, sync)"
        ;;
    esac
    ;;
  journal)
    require_config
    sub="${2:-}"
    case "$sub" in
      recent)
        count="${3:-20}"
        pai_lite_journal_recent "$count"
        ;;
      list)
        days="${3:-7}"
        pai_lite_journal_list "$days"
        ;;
      "")
        pai_lite_journal_recent 20
        ;;
      *)
        pai_lite_die "unknown journal subcommand: $sub (use: recent, list)"
        ;;
    esac
    ;;
  network)
    require_config
    sub="${2:-status}"
    case "$sub" in
      status)
        pai_lite_network_status
        ;;
      *)
        pai_lite_die "unknown network subcommand: $sub (use: status)"
        ;;
    esac
    ;;
  federation)
    require_config
    # Source federation library
    source "$root_dir/lib/federation.sh"
    sub="${2:-status}"
    case "$sub" in
      status)
        federation_status
        ;;
      tick)
        federation_tick
        ;;
      elect)
        federation_elect
        ;;
      heartbeat)
        federation_heartbeat_publish
        ;;
      *)
        pai_lite_die "unknown federation subcommand: $sub (use: status, tick, elect, heartbeat)"
        ;;
    esac
    ;;
  doctor)
    # Comprehensive health check
    echo "pai-lite doctor - system health check"
    echo "======================================"
    echo ""

    all_ok=true
    warnings=0

    #------------------------------------------
    # Required tools
    #------------------------------------------
    echo "Required tools:"

    # git
    if command -v git >/dev/null 2>&1; then
      echo "  [ok] git: $(git --version | head -1)"
    else
      echo "  [FAIL] git: NOT FOUND"
      all_ok=false
    fi

    # gh (GitHub CLI)
    if command -v gh >/dev/null 2>&1; then
      echo "  [ok] gh: $(gh --version | head -1)"
      # Check auth status
      if gh auth status >/dev/null 2>&1; then
        echo "    -> authenticated"
      else
        echo "    -> [warn] not authenticated (run: gh auth login)"
        warnings=$((warnings + 1))
      fi
    else
      echo "  [FAIL] gh: NOT FOUND"
      echo "    Install: https://cli.github.com/"
      all_ok=false
    fi

    # yq
    if command -v yq >/dev/null 2>&1; then
      echo "  [ok] yq: $(yq --version 2>&1 | head -1)"
    else
      echo "  [FAIL] yq: NOT FOUND"
      echo "    Install: brew install yq"
      all_ok=false
    fi

    # jq
    if command -v jq >/dev/null 2>&1; then
      echo "  [ok] jq: $(jq --version)"
    else
      echo "  [FAIL] jq: NOT FOUND"
      echo "    Install: brew install jq"
      all_ok=false
    fi

    # curl
    if command -v curl >/dev/null 2>&1; then
      echo "  [ok] curl: $(curl --version | head -1)"
    else
      echo "  [FAIL] curl: NOT FOUND"
      all_ok=false
    fi

    echo ""

    #------------------------------------------
    # Optional tools
    #------------------------------------------
    echo "Optional tools:"

    # tmux
    if command -v tmux >/dev/null 2>&1; then
      echo "  [ok] tmux: $(tmux -V)"
    else
      echo "  [warn] tmux: not found (needed for claude-code/codex adapters)"
      echo "    Install: brew install tmux"
      warnings=$((warnings + 1))
    fi

    # ttyd
    if command -v ttyd >/dev/null 2>&1; then
      echo "  [ok] ttyd: $(ttyd --version 2>&1 | head -1)"
    else
      echo "  [warn] ttyd: not found (optional web terminal access)"
      echo "    Install: brew install ttyd"
      warnings=$((warnings + 1))
    fi

    # tsort (usually part of coreutils)
    if command -v tsort >/dev/null 2>&1; then
      echo "  [ok] tsort: available"
    else
      echo "  [warn] tsort: not found (needed for flow dependency analysis)"
      warnings=$((warnings + 1))
    fi

    # shell linter
    if command -v shellcheck >/dev/null 2>&1; then
      echo "  [ok] shellcheck: $(shellcheck --version | grep version:)"
    else
      echo "  [warn] shellcheck: not found (for development)"
      warnings=$((warnings + 1))
    fi

    # tailscale
    if command -v tailscale >/dev/null 2>&1; then
      echo "  [ok] tailscale: available"
      if tailscale status >/dev/null 2>&1; then
        ts_hostname=$(tailscale status --json 2>/dev/null | jq -r '.Self.DNSName // empty' 2>/dev/null | sed 's/\.$//')
        if [[ -n "$ts_hostname" ]]; then
          echo "    -> connected as: $ts_hostname"
        else
          echo "    -> connected"
        fi
      else
        echo "    -> [warn] not connected (run: tailscale up)"
        warnings=$((warnings + 1))
      fi
    else
      echo "  [info] tailscale: not installed (optional, for multi-machine setup)"
    fi

    echo ""

    #------------------------------------------
    # Configuration
    #------------------------------------------
    echo "Configuration:"

    config_path="$(pai_lite_config_path 2>/dev/null || echo "")"
    pointer_path="$(pai_lite_pointer_config_path)"

    if [[ -n "$config_path" && -f "$config_path" ]]; then
      echo "  [ok] config: $config_path"

      # Check state repo
      state_repo="$(pai_lite_state_repo_slug 2>/dev/null || echo "")"
      if [[ -n "$state_repo" && "$state_repo" != *"your-username"* ]]; then
        echo "    -> state_repo: $state_repo"

        # Check if state repo is cloned
        state_dir="$(pai_lite_state_repo_dir 2>/dev/null || echo "")"
        if [[ -n "$state_dir" && -d "$state_dir/.git" ]]; then
          echo "    -> state dir: $state_dir (exists)"
        else
          echo "    -> [warn] state dir: not cloned"
          warnings=$((warnings + 1))
        fi
      else
        echo "    -> [warn] state_repo: using placeholder value"
        warnings=$((warnings + 1))
      fi
    else
      echo "  [warn] config: not found at $pointer_path"
      echo "    Run: pai-lite init"
      warnings=$((warnings + 1))
    fi

    echo ""

    #------------------------------------------
    # Adapters
    #------------------------------------------
    echo "Adapter checks:"

    # Source adapters for doctor functions
    for adapter_file in "$root_dir"/adapters/*.sh; do
      [[ -f "$adapter_file" ]] || continue
      adapter_name="$(basename "$adapter_file" .sh)"

      # Skip manual adapter (no tools needed)
      [[ "$adapter_name" == "manual" ]] && continue

      # shellcheck source=/dev/null
      source "$adapter_file" 2>/dev/null || continue

      # Check if adapter has doctor function
      doctor_func="adapter_${adapter_name//-/_}_doctor"
      if declare -f "$doctor_func" >/dev/null 2>&1; then
        echo ""
        echo "--- $adapter_name ---"
        if ! "$doctor_func"; then
          all_ok=false
        fi
      fi
    done

    echo ""

    #------------------------------------------
    # Triggers
    #------------------------------------------
    echo "Triggers:"
    uname_out="$(uname -s)"
    case "$uname_out" in
      Darwin)
        # Count triggers; use || true to handle missing directory
        trigger_count=$( (find "$HOME/Library/LaunchAgents" -maxdepth 1 -name 'com.pai-lite.*.plist' 2>/dev/null || true) | wc -l | tr -d ' ')
        if [[ "$trigger_count" -gt 0 ]]; then
          echo "  [ok] launchd: $trigger_count trigger(s) installed"
        else
          echo "  [warn] launchd: no triggers installed"
          echo "    Run: pai-lite triggers install"
          warnings=$((warnings + 1))
        fi
        ;;
      Linux)
        if command -v systemctl >/dev/null 2>&1; then
          # Count triggers; use || true to handle missing directory
          trigger_count=$( (find "$HOME/.config/systemd/user" -maxdepth 1 -name 'pai-lite-*.service' 2>/dev/null || true) | wc -l | tr -d ' ')
          if [[ "$trigger_count" -gt 0 ]]; then
            echo "  [ok] systemd: $trigger_count trigger(s) installed"
          else
            echo "  [warn] systemd: no triggers installed"
            echo "    Run: pai-lite triggers install"
            warnings=$((warnings + 1))
          fi
        else
          echo "  [warn] systemctl not available"
        fi
        ;;
    esac

    echo ""

    #------------------------------------------
    # Skills and Hooks
    #------------------------------------------
    echo "Skills and Hooks:"

    # Check for installed skills in state harness directory
    harness_dir="$(pai_lite_state_harness_dir 2>/dev/null || echo "")"
    claude_skills="$harness_dir/.claude/commands"
    if [[ -n "$harness_dir" && -d "$claude_skills" ]]; then
      skill_count=$(find "$claude_skills" -maxdepth 1 -name '*.md' 2>/dev/null | wc -l | tr -d ' ')
      pai_lite_skills=0
      for skill in pai-briefing pai-suggest pai-analyze-issue pai-elaborate pai-health-check pai-learn pai-sync-learnings pai-techdebt pai-context-sync; do
        [[ -f "$claude_skills/$skill.md" ]] && pai_lite_skills=$((pai_lite_skills + 1))
      done
      if [[ "$pai_lite_skills" -gt 0 ]]; then
        echo "  [ok] skills: $pai_lite_skills pai-lite skills installed in $claude_skills"
      else
        echo "  [warn] skills: no pai-lite skills found in $claude_skills"
        echo "    Run: pai-lite init"
        warnings=$((warnings + 1))
      fi
    else
      echo "  [warn] skills: state harness .claude/commands does not exist"
      echo "    Run: pai-lite init"
      warnings=$((warnings + 1))
    fi

    # Check for stop hook script
    hook_script="$HOME/.local/bin/pai-lite-on-stop"
    if [[ -x "$hook_script" ]]; then
      echo "  [ok] hook script: $hook_script"
    else
      echo "  [warn] hook script: not found at $hook_script"
      echo "    Run: pai-lite init"
      warnings=$((warnings + 1))
    fi

    # Check for hook configuration in settings.json
    claude_settings="$HOME/.claude/settings.json"
    if [[ -f "$claude_settings" ]]; then
      if grep -q 'pai-lite-on-stop' "$claude_settings" 2>/dev/null; then
        echo "  [ok] hook config: pai-lite hook configured in settings.json"
      else
        echo "  [warn] hook config: pai-lite hook not in settings.json"
        echo "    Run: pai-lite init (or add manually)"
        warnings=$((warnings + 1))
      fi
    else
      echo "  [warn] hook config: $claude_settings not found"
      warnings=$((warnings + 1))
    fi

    echo ""

    #------------------------------------------
    # Notifications
    #------------------------------------------
    echo "Notifications:"
    pai_topic="$(pai_lite_config_notifications_topic "pai" 2>/dev/null || echo "")"
    if [[ -n "$pai_topic" ]]; then
      echo "  [ok] ntfy.sh topics configured"
      echo "    -> pai: $pai_topic"
      agents_topic="$(pai_lite_config_notifications_topic "agents" 2>/dev/null || echo "")"
      [[ -n "$agents_topic" ]] && echo "    -> agents: $agents_topic"
      public_topic="$(pai_lite_config_notifications_topic "public" 2>/dev/null || echo "")"
      [[ -n "$public_topic" ]] && echo "    -> public: $public_topic"
    else
      echo "  [warn] ntfy.sh topics not configured"
      warnings=$((warnings + 1))
    fi

    echo ""

    #------------------------------------------
    # Summary
    #------------------------------------------
    echo "======================================"
    if $all_ok && [[ $warnings -eq 0 ]]; then
      echo "[OK] All checks passed"
      exit 0
    elif $all_ok; then
      echo "[OK] Required checks passed ($warnings warning(s))"
      exit 0
    else
      echo "[FAIL] Some required checks failed ($warnings warning(s))"
      exit 1
    fi
    ;;
  *)
    pai_lite_die "unknown command: $cmd"
    ;;
esac
